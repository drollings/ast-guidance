const std = @import("std");
const ast_parser = @import("ast_parser.zig");

pub const DepsGenerator = struct {
    allocator: std.mem.Allocator,
    cwd: []const u8,

    pub fn init(allocator: std.mem.Allocator, cwd: []const u8) DepsGenerator {
        return .{
            .allocator = allocator,
            .cwd = cwd,
        };
    }

    pub fn generateDependencies(self: *DepsGenerator, src_dir: []const u8) !void {
        const src_path = if (std.fs.path.isAbsolute(src_dir))
            try self.allocator.dupe(u8, src_dir)
        else
            try std.fs.path.join(self.allocator, &.{ self.cwd, src_dir });
        defer self.allocator.free(src_path);

        var dir = try std.fs.openDirAbsolute(src_path, .{ .iterate = true });
        defer dir.close();

        var files: std.ArrayList([]const u8) = .{};
        defer {
            for (files.items) |f| self.allocator.free(f);
            files.deinit(self.allocator);
        }

        var walker = try dir.walk(self.allocator);
        defer walker.deinit();

        while (try walker.next()) |entry| {
            if (entry.kind != .file) continue;
            if (!std.mem.endsWith(u8, entry.basename, ".zig")) continue;
            if (std.mem.eql(u8, entry.basename, "build.zig")) continue;

            const rel_path = try self.allocator.dupe(u8, entry.path);
            errdefer self.allocator.free(rel_path);
            try files.append(self.allocator, rel_path);
        }

        var deps_map: std.StringHashMapUnmanaged(std.ArrayList([]const u8)) = .{};
        defer {
            var iter = deps_map.iterator();
            while (iter.next()) |entry| {
                self.allocator.free(entry.key_ptr.*);
                for (entry.value_ptr.*.items) |item| {
                    self.allocator.free(item);
                }
                entry.value_ptr.*.deinit(self.allocator);
            }
            deps_map.deinit(self.allocator);
        }

        for (files.items) |rel_path| {
            const full_path = try std.fs.path.join(self.allocator, &.{ src_path, rel_path });
            defer self.allocator.free(full_path);

            var all_imports = std.StringHashMap(void).init(self.allocator);
            defer all_imports.deinit();

            const file_contents = std.fs.cwd().readFileAlloc(self.allocator, full_path, std.math.maxInt(usize)) catch continue;
            defer self.allocator.free(file_contents);

            var i: usize = 0;
            while (i + 9 < file_contents.len) {
                if (file_contents[i] == '@' and
                    file_contents[i + 1] == 'i' and file_contents[i + 2] == 'm' and file_contents[i + 3] == 'p' and
                    file_contents[i + 4] == 'o' and file_contents[i + 5] == 'r' and file_contents[i + 6] == 't' and
                    file_contents[i + 7] == '(' and file_contents[i + 8] == '"')
                {
                    const start = i + 9;
                    var end = start;
                    while (end < file_contents.len and file_contents[end] != '"') end += 1;
                    if (end < file_contents.len and end > start) {
                        const import_path = file_contents[start..end];
                        all_imports.put(import_path, {}) catch {};
                        i = end + 1;
                        continue;
                    }
                }
                i += 1;
            }

            var deps: std.ArrayList([]const u8) = .{};
            errdefer {
                for (deps.items) |d| self.allocator.free(d);
                deps.deinit(self.allocator);
            }

            var import_iter = all_imports.iterator();
            while (import_iter.next()) |entry| {
                const resolved = try self.resolveImport(rel_path, entry.key_ptr.*);
                if (resolved) |r| {
                    try deps.append(self.allocator, r);
                }
            }

            try deps_map.put(self.allocator, try self.allocator.dupe(u8, rel_path), deps);
        }

        var out_buf: [4096]u8 = undefined;
        var fw = std.fs.File.stdout().writer(&out_buf);
        const stdout = &fw.interface;

        try stdout.writeAll("# Auto-generated by: guidance deps --src <src_dir> | sed ...\n");
        try stdout.writeAll("# __finish__X -> lint marker, __success__X -> test marker\n\n");

        for (files.items) |file| {
            if (deps_map.get(file)) |file_deps| {
                if (file_deps.items.len == 0) continue;

                // __finish__file.zig depends on __success__file.zig (lint gates on test)
                // plus __success__dep.zig for each dependency (dependency test triggers re-lint)
                try stdout.writeAll("__finish____src__");
                try stdout.writeAll(file);
                try stdout.writeAll(": __src__");
                try stdout.writeAll(file);
                try stdout.writeAll(" \\\n");

                for (file_deps.items) |dep| {
                    try stdout.writeAll("  __success____src__");
                    try stdout.writeAll(dep);
                    try stdout.writeAll(" \\\n");
                }

                try stdout.writeAll("\n");
            }
        }

        try stdout.flush();
    }

    fn resolveImport(self: *DepsGenerator, from_file: []const u8, import_path: []const u8) !?[]const u8 {
        if (import_path.len > 0 and import_path[0] == '/') {
            return null;
        }

        const from_dir = std.fs.path.dirname(from_file);
        var candidate = if (from_dir) |dir|
            try std.fs.path.join(self.allocator, &.{ dir, import_path })
        else
            try self.allocator.dupe(u8, import_path);
        errdefer self.allocator.free(candidate);

        if (std.mem.startsWith(u8, candidate, "./")) {
            const cleaned = try self.allocator.dupe(u8, candidate[2..]);
            self.allocator.free(candidate);
            const result = try self.resolveImportPath(cleaned);
            self.allocator.free(cleaned);
            return result;
        }

        const result = try self.resolveImportPath(candidate);
        self.allocator.free(candidate);
        return result;
    }

    fn resolveImportPath(self: *DepsGenerator, import_path: []const u8) !?[]const u8 {
        const test_path = try std.fs.path.join(self.allocator, &.{ self.cwd, "src", import_path });
        defer self.allocator.free(test_path);

        if (std.fs.openFileAbsolute(test_path, .{})) |f| {
            defer f.close();
            if (f.stat()) |stat| {
                if (stat.kind == .file) return try self.allocator.dupe(u8, import_path);
            } else |_| {}
        } else |_| {}

        const with_zig = try std.fmt.allocPrint(self.allocator, "{s}.zig", .{import_path});
        defer self.allocator.free(with_zig);

        const test_path_zig = try std.fs.path.join(self.allocator, &.{ self.cwd, "src", with_zig });
        defer self.allocator.free(test_path_zig);

        if (std.fs.openFileAbsolute(test_path_zig, .{})) |f| {
            defer f.close();
            return try self.allocator.dupe(u8, with_zig);
        } else |_| {}

        return null;
    }
};
